<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Daily Claims — Eren Panel</title>
  <style>
    :root { --bg:#071022; --card:#0f1724; --muted:#9fbddf; --accent:#ffd166; }
    body{margin:0;font-family:Poppins,system-ui,Arial;background:var(--bg);color:#eaf6ff}
    .wrap{max-width:980px;margin:24px auto;padding:18px}
    .card{background:var(--card);padding:18px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.6)}
    h1{margin:0 0 12px}
    .fields{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .label{color:var(--muted);font-size:13px}
    .value{font-weight:800}
    .blurred{filter:blur(6px);user-select:none;pointer-events:none}
    .unblur{filter:none;pointer-events:auto}
    .meta{display:flex;justify-content:space-between;align-items:center;margin-top:12px;color:var(--muted)}
    .countdown{font-weight:800;color:var(--accent)}
    a.link { color:#9fd6ff; text-decoration:underline }
    /* ad overlay */
    #ad-overlay { position:fixed; inset:0; display:flex;align-items:center;justify-content:center; z-index:20000; pointer-events:none; }
    #ad-card { width:min(92vw,760px); background:#081226; border-radius:12px; padding:12px; pointer-events:auto; box-shadow:0 18px 60px rgba(0,0,0,.7) }
    #ad-close { position:absolute; top:8px; right:10px; background:rgba(0,0,0,.35); border:none; color:#fff; font-size:18px; padding:6px 8px; border-radius:6px; cursor:pointer }
    .ad-content img, .ad-content video { width:100%; height:auto; border-radius:8px; display:block; }
    .ad-text { color:#fff; font-size:16px; padding:6px 0; }
    /* small */
    .small { color:var(--muted); font-size:13px }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Daily Panel Reveal</h1>
      <p class="small">Panels unblur for 5 minutes every 12 hours (server time). Ads appear periodically and are synced from admin.</p>

      <div id="no-panels" class="small" style="display:none">No panels available right now.</div>

      <div id="panel-card" style="display:none">
        <div><span class="label">Email</span> <span id="d-email" class="value blurred">********@***.***</span></div>
        <div style="margin-top:8px"><span class="label">Password</span> <span id="d-pass" class="value blurred">********</span></div>
        <div style="margin-top:8px"><span class="label">Panel URL</span> <span id="d-url" class="value blurred">https://*****</span></div>

        <div class="meta">
          <div>Next reveal in <span id="countdown" class="countdown">--:--:--</span></div>
          <div class="small">Visible for <span id="dur">05:00</span></div>
        </div>
      </div>
    </div>
  </div>

  <!-- ad overlay (hidden by default) -->
  <div id="ad-overlay" style="display:none">
    <div id="ad-card" role="dialog" aria-label="Advertisement">
      <button id="ad-close" aria-label="Close ad">✕</button>
      <div class="ad-content" id="ad-content"></div>
      <div style="margin-top:8px;text-align:center" id="ad-caption"></div>
    </div>
  </div>

  <!-- firebase compat SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

  <script>
  /***********************
   * Configuration
   ***********************/
  const firebaseConfig = {
    apiKey: "AIzaSyAXZQi1Wdwf7oHRVapWNGgcCYtd4Dy5kQk",
    authDomain: "eren-c4b30.firebaseapp.com",
    projectId: "eren-c4b30",
    storageBucket: "eren-c4b30.appspot.com",
    messagingSenderId: "91279547740",
    appId: "1:91279547740:web:11cc9f1eb5423f94993599",
    measurementId: "G-LPF98ZZ527"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // serverOffset to align client clocks to server
  let serverOffset = 0; // ms (serverTime - localTime)

  /***********************
   * SERVER TIME SYNC
   * We write a doc with serverTimestamp then read it back to compute offset.
   ***********************/
  async function syncServerTime() {
    try {
      const ref = db.collection('serverTime').doc('now');
      // write server timestamp
      await ref.set({ ts: firebase.firestore.FieldValue.serverTimestamp() });
      // read back
      const snap = await ref.get();
      const data = snap.data();
      if (!data || !data.ts) {
        console.warn('Server timestamp not yet available — using local time fallback.');
        serverOffset = 0;
        return;
      }
      const serverMs = data.ts.toDate().getTime();
      serverOffset = serverMs - Date.now();
      console.log('Server time synced. Offset (ms):', serverOffset);
    } catch (e) {
      console.error('Time sync failed, using local time:', e);
      serverOffset = 0;
    }
  }

  // run sync once on load, then refresh every 5 minutes to reduce drift
  syncServerTime();
  setInterval(syncServerTime, 5 * 60 * 1000);

  /***********************
   * PANELS logic
   ***********************/
  const KEY_CLAIMS = 'daily_claims'; // local backup if you ever want it
  let panels = []; // array of panel objects { email, password, panel_url, createdAt }

  const elNoPanels = document.getElementById('no-panels');
  const elPanelCard = document.getElementById('panel-card');
  const elEmail = document.getElementById('d-email');
  const elPass = document.getElementById('d-pass');
  const elUrl = document.getElementById('d-url');
  const elCountdown = document.getElementById('countdown');
  const elDur = document.getElementById('dur');

  // load from Firestore in real-time and keep local panels array updated
  db.collection('panels').orderBy('createdAt', 'desc').onSnapshot(snapshot => {
    panels = snapshot.docs.map(doc => {
      const d = doc.data();
      return { id: doc.id, email: d.email || '', password: d.password || '', panel_url: d.panel_url || '', createdAt: d.createdAt || null };
    });
    // update UI immediately
    renderPanel();
  }, err => {
    console.error('Failed to load panels:', err);
  });

  function renderPanel() {
    if (!panels.length) {
      elNoPanels.style.display = 'block';
      elPanelCard.style.display = 'none';
      return;
    }
    elNoPanels.style.display = 'none';
    elPanelCard.style.display = 'block';
    showPanel(panels[0]);
  }

  function showPanel(panel) {
    elEmail.textContent = panel.email || '—';
    elPass.textContent = panel.password || '—';
    elUrl.innerHTML = panel.panel_url ? `<a class="link" href="${panel.panel_url}" target="_blank" rel="noreferrer">${panel.panel_url}</a>` : '—';
  }

  function formatHMS(seconds) {
    seconds = Math.max(0, Math.floor(seconds));
    const h = Math.floor(seconds / 3600).toString().padStart(2,'0');
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2,'0');
    const s = (seconds % 60).toString().padStart(2,'0');
    return `${h}:${m}:${s}`;
  }

  // Reveal schedule: every 12 hours, for 5 minutes.
  const REVEAL_INTERVAL = 12 * 3600 * 1000; // 12 hours in ms
  const REVEAL_DURATION = 5 * 60 * 1000; // 5 minutes in ms

  function tickPanels() {
    // use server-corrected "now"
    const now = Date.now() + serverOffset;
    if (!panels.length) {
      elNoPanels.style.display = 'block';
      elPanelCard.style.display = 'none';
      return;
    }
    elNoPanels.style.display = 'none';
    elPanelCard.style.display = 'block';

    // align reveals to multiples of REVEAL_INTERVAL since epoch
    const lastReveal = Math.floor(now / REVEAL_INTERVAL) * REVEAL_INTERVAL;
    const revealEnd = lastReveal + REVEAL_DURATION;
    const nextReveal = lastReveal + REVEAL_INTERVAL;

    if (now >= lastReveal && now < revealEnd) {
      // currently in reveal window -> unblur
      elEmail.classList.remove('blurred'); elEmail.classList.add('unblur');
      elPass.classList.remove('blurred'); elPass.classList.add('unblur');
      elUrl.classList.remove('blurred'); elUrl.classList.add('unblur');

      const secsLeft = Math.ceil((revealEnd - now) / 1000);
      elCountdown.textContent = formatHMS(secsLeft);
    } else {
      // not in reveal -> blur
      elEmail.classList.add('blurred'); elEmail.classList.remove('unblur');
      elPass.classList.add('blurred'); elPass.classList.remove('unblur');
      elUrl.classList.add('blurred'); elUrl.classList.remove('unblur');

      const secsToReveal = Math.ceil((nextReveal - now) / 1000);
      elCountdown.textContent = formatHMS(secsToReveal);
    }
  }

  // run tickPanels every second
  setInterval(tickPanels, 1000);
  tickPanels();

  /***********************
   * ADS logic
   ***********************/
  let ads = []; // live array of ads from Firestore
  const adOverlay = document.getElementById('ad-overlay');
  const adContent = document.getElementById('ad-content');
  const adCaption = document.getElementById('ad-caption');
  const adClose = document.getElementById('ad-close');

  let adTimer = null;
  let nextAdTimeout = null;

  // Settings
  const FIRST_AD_DURATION = 10 * 1000; // 10 seconds on initial load
  const REAPPEAR_MIN = 30 * 1000; // 30s
  const REAPPEAR_MAX = 90 * 1000; // 90s

  // helper: shuffle array (Fisher-Yates)
  function shuffleInPlace(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // subscribe to advertisements collection
  db.collection('advertisements').orderBy('createdAt','desc').onSnapshot(snapshot => {
    ads = snapshot.docs.map(doc => {
      const d = doc.data();
      return { id: doc.id, type: d.type, payload: d.payload, meta: d.meta || {}, createdAt: d.createdAt || null };
    });
    // start showing an ad on first load only if overlay currently hidden
    if (ads.length && adOverlay.style.display === 'none') {
      // show immediately for 10s
      showAdOnce(FIRST_AD_DURATION);
    }
  }, err => {
    console.error('Failed to load ads:', err);
  });

  // Render a given ad object into overlay
  function renderAd(ad) {
    adContent.innerHTML = '';
    adCaption.textContent = '';
    if (!ad) return;

    if (ad.type === 'text') {
      const p = document.createElement('div');
      p.className = 'ad-text';
      p.textContent = ad.payload || '';
      adContent.appendChild(p);
    } else if (ad.type === 'image') {
      const a = document.createElement('a');
      a.href = ad.meta?.link || '#';
      a.target = '_blank';
      a.rel = 'noreferrer';
      const img = document.createElement('img');
      img.src = ad.payload || '';
      img.alt = ad.meta?.title || 'Ad';
      a.appendChild(img);
      adContent.appendChild(a);
    } else if (ad.type === 'video') {
      // payload could be mp4 url or youtube link
      const isYouTube = /youtube\.com|youtu\.be/.test(ad.payload || '');
      if (isYouTube) {
        // parse id
        const match = ad.payload.match(/(?:v=|\/)([0-9A-Za-z_-]{11})/);
        const vId = match ? match[1] : null;
        if (vId) {
          const iframe = document.createElement('iframe');
          iframe.width = '100%';
          iframe.height = '420';
          iframe.src = 'https://www.youtube.com/embed/' + vId + '?rel=0';
          iframe.frameBorder = '0';
          iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
          iframe.allowFullscreen = true;
          adContent.appendChild(iframe);
        } else {
          const p = document.createElement('div'); p.textContent = 'Invalid YouTube link'; adContent.appendChild(p);
        }
      } else {
        const a = document.createElement('a');
        a.href = ad.meta?.link || '#';
        a.target = '_blank';
        a.rel = 'noreferrer';
        const v = document.createElement('video');
        v.src = ad.payload || '';
        v.controls = true;
        v.autoplay = false;
        v.style.width = '100%';
        a.appendChild(v);
        adContent.appendChild(a);
      }
    }

    if (ad.meta && ad.meta.title) adCaption.textContent = ad.meta.title;
  }

  // show overlay for given ms, then hide
  function showAdForMs(ms, adObj) {
    if (!adObj) return;
    renderAd(adObj);
    adOverlay.style.display = 'flex';
    // clear any existing timers
    if (adTimer) { clearTimeout(adTimer); adTimer = null; }
    if (nextAdTimeout) { clearTimeout(nextAdTimeout); nextAdTimeout = null; }

    adTimer = setTimeout(() => {
      hideAd();
      scheduleNextAdRandom();
    }, ms);
  }

  // hide immediately
  function hideAd() {
    adOverlay.style.display = 'none';
    adContent.innerHTML = '';
    adCaption.textContent = '';
    if (adTimer) { clearTimeout(adTimer); adTimer = null; }
  }

  adClose.addEventListener('click', () => {
    hideAd();
    scheduleNextAdRandom();
  });

  // show one ad now (choose random ad)
  function showAdOnce(durationMs = FIRST_AD_DURATION) {
    if (!ads.length) return;
    const shuffled = [...ads];
    shuffleInPlace(shuffled);
    const ad = shuffled[0];
    showAdForMs(durationMs, ad);
  }

  // schedule a next ad at random delay between REAPPEAR_MIN and REAPPEAR_MAX
  function scheduleNextAdRandom() {
    if (!ads.length) return;
    const delay = REAPPEAR_MIN + Math.floor(Math.random() * (REAPPEAR_MAX - REAPPEAR_MIN));
    if (nextAdTimeout) { clearTimeout(nextAdTimeout); nextAdTimeout = null; }
    nextAdTimeout = setTimeout(() => {
      // choose a random ad and show for 10s (could be customized)
      const shuffled = [...ads];
      shuffleInPlace(shuffled);
      // if multiple ads, show them in rotation quickly (shuffle ensures random order)
      showAdForMs(10000, shuffled[0]);
    }, delay);
  }

  // If ads already loaded on page open, show initial ad
  // (if ads arrive later onSnapshot they trigger show inside onSnapshot)
  // Use a small timeout to ensure serverOffset may have been calculated (optional)
  setTimeout(() => {
    if (ads.length) showAdOnce(FIRST_AD_DURATION);
    else {
      // no ads yet — will show when snapshot arrives
    }
    // schedule next regardless so ad loop is running
    scheduleNextAdRandom();
  }, 1000);

  </script>
</body>
</html>
